// Наследование-заимствование свойств и методов
//родительского класса в производном классе
//синтаксис:
// class имя_произв_класса :[тип_наследования] имя_родительского_класса1,
// необязательный элемент-квадр ск [тип_наследования] имя_родительского_класса2
//public protected private-тип_наследования,необязательно указывать
//                        в заголовке при наследовании
//в род.классе             public:      protected:        private: 
//public:                  public:      protected:       private:
//protected:               protected    protected:       private:
//private:                 недоступн     недоступн        недоступн
//2.метод,переопред. в дочернем классе полностью заменит
//унаследованный род. метод
//чтобы при запуске нового дочернего метода тоже выполнять род.
//необходимо указать это явно
//в род классе void weapon::reload(){};
//в дочернем классе void rifle::reload():weapon::reload(),...{};
//3.если объявить метод со словом virtual то этот метод можно 
//не реализовывать,а реализовать в дочернем классе
//4. void fnc1(const тип1 параметр1(не менять,самоограничение);тип2 параметр2)
// объявление когстантного метода класса
//запрещает менять ему какое-либо из свойств объекта
//void fnc1(тип1 параметр1;тип2 параметр2) const
//запрет на изменение любого типа класса
//{
//  параметр1=10;
//}
//5.приведение типов
//при попытке сложить\поделить\умножить\вычесть 
//нет необходимости приводить к одному типу данных
//приведение чисел-автоматическое
//приведение строк-прописывать

#include "stdafx.h"
#include <iostream>

int main()
{
	int i = -15;
	double d = 1000.5e+03;//=1000.5*10^3=1000.5*pow(10,3)
	float result1;
	long long result2;
	result1 = i + d;
	result2 = i / d;
	//с char-нужно приводить
	const char *ch1 = "123.4";//const wchar_t *ch1 = L"123";-юникод 4 байта {'1','2','3',0}={'1','2','3''\0'}
	const char *ch2 = "456.7";//
	//? ? ? = ch1 + ch2;
	//std::string "123456";
	i= atoi(ch1);//в int или long long
	d= atof(ch2);//double
	



	
	return 0;
}

