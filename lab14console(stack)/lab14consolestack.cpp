
#include "stdafx.h"
#include <iostream> 
#include <stack> // подключаем библиотеку для использования стека 
#include <queue> // подключили библиотеку для использования очереди 
#include <deque> // подключили библиотеку для использования дека 

/*
#include <list> // подключили библиотеку для использования списка
#include <set> // подключили библиотеку для использования множества
#include <map> // подключили библиотеку для использования ассоциативного массива
*/

int main()
{
	setlocale(LC_ALL, "rus");
	/*
	Стек — это структура данных, которая работает 
	по принципу FILO(first in — last out; первый пришел — последний ушел).

	В стеке нет индексов,т.е. нельзя обратиться к определенному элементу.
	Каждый элемент имеет указатель на следующий элемент.
	Головной элемент указывает на NULL.

	Достоинство: операции удаления и добавления элемента делаются за const время.

	*/
	/*Очередь очень похожа на стек и в тоже время является его противоположностью
	— первым мы получим обратно не тот элемент, что мы добавили последним, а тот,
	что “стоит в очереди” дольше всех. Очередь очень удобная структура, но несмотря, на то,
	что принцип ее работы схож со стеком,
	в эффективной реализации есть небольшое отличие.
	Для стека мы могли схитрить и выделить приемлемый по размеру участок памяти,
	в случае чего его расширяя, потому-что стек то уменьшается, то увеличивается, т.к.
	элементы и добавляются и удаляются “с одного конца”. Если же мы представим работу очереди,
	то она будет “ползти в памяти” — начало будет постоянно сдвигаться вверх, поэтому трюк,
	который применим для стека, будет работать хуже и тут уже намного лучше 
	будет использовать двусвязный список 
	(и не забудьте хранить указатели на первый и последний элементы).
	Также есть дек (двусторонняя очередь — deque). В ней можно добавлять элементы как в конец, 
	так и в начало. И забирать их тоже и с конца и с начала.*/

	std::stack<int> stackInt;//stack <тип данных> <имя>; -создание стека 
	int i = 0, a = 0;
	std::cout << "Введите 5 целых чисел: " << std::endl;
	while (i != 5) {
		std::cin >> a;
		stackInt.push(a); // добавляем введенное число (автоматически заполняет стек)
		i++;
	}

	if (stackInt.empty()) // проверяем пуст ли стек (нет) 
		std::cout << "Стек не пуст";

	std::cout << "Верхний элемент стека: " << stackInt.top() << std::endl;
	stackInt.pop(); // удаляем верхний элемент (автоматически очищает стек)

	std::cout << "Новый верхний элемент: " << stackInt.top()<< std::endl;

	// ЗАДАНИЕ 1 
	/*
	Проверить правильность расстановки скобок (,),[,],{,}
	в введенном пользователем выражении за линейное время
	(один просмотр выражения).
	2+4-5(87192479_7348){72648]76823[] -> no
	({}) -> yes
	({)} -> no
	*/ 

	//решение 
	/*
	Считываем элемент.
	Если это (,[ или {, то помещаем ее в стек.
	Если это ),] или }, то сравниваем с верхним элементом стека.
	Если образовалась пара, то верхний элемент стека удаляем.
	Иначе - выражение неправильное.

	Когда все элементы считали, то проверяем стек на пустоту.
	Если стек пуст, то выражение правильное.
	Иначе - выражение неправильное.
	*/

	/*ОЧЕРЕДЬ
	Очередь — это структура данных, которая построена по принципу
	LILO (last in — last out: последним пришел — последним вышел).
	*/

	std::queue <int> MyQueue; // создали очередь 
	std::cout << "Введите 7 чисел: " << std::endl;
	for (i = 0; i < 7; i++) {
		std::cin >> a;
		MyQueue.push(a); // добавляем в очередь элементы 
	}
	std::cout << std::endl;
	std::cout << "Первый элемент в очереди: " << MyQueue.front() << std::endl;
	MyQueue.pop(); // удаляем элемент из очереди 
	std::cout << "Первый элемент (после удаления): " << MyQueue.front() << std::endl;

	if (!MyQueue.empty()) // проверяем пуста ли очередь (нет) 
		std::cout << "Очередь не пуста!";
	/*
	Очередь с приоритетом (priority_queue) — это обычная очередь,
	но в ней новый элемент добавляется в такое место,
	чтобы очередь была отсортирована по убыванию.
	*/

	std::priority_queue <int> priority_q; // объявляем приоритетную очередь 

	std::cout << "Введите 7 чисел: " << std::endl;
	for (i = 0; i < 7; i++) {
		std::cin >> a;
		priority_q.push(a); // добавляем элементы в очередь 
		std::copy(MyQueue.front(), MyQueue.back(), std::ostream_iterator<int>(cout, " "));
	}
	// выводим первый 
	std::cout << "Первый элемент очереди: " << priority_q.top();

	// ЗАДАНИЕ 2 
	/*
	Программа на вход получает список школьников.
	В каждой строке сначала записан номер класса (число, равное 9, 10 или 11),
	затем (через пробел) – фамилия.
	Необходимо вывести список по классам:
	сначала всех учащихся 9 класса, затем – 10, затем – 11.
	Внутри одного класса порядок вывода должен быть таким же, как на входе.
	*/

	/*
	Создаем 3 очереди (свою для каждого класса).

	Считываем очередную строку. В зависимости от класса
	добавляем фамилию в соответствующую очередь

	Когда все считали, выводим очереди последовательно:

	сначала для 9 класса, затем очередь 10 класса,
	а в самом конце очередь 11 класса.
	*/

	/*
	Деком (англ. deque – аббревиатура от double-ended queue, двухсторонняя очередь)
	называется структура данных, в которую можно удалять и добавлять элементы 
как в начало, так и в конец. 

Дек хранится в памяти так же, как и очередь. 
*/ 

//ЗАДАЧА 3 
/*
Проверить, является ли введенная строка палиндромом
(читается одинаково слева направо и справа налево). Использовать дек.
*/

/*

Считываем строку посимвольно. каждый символ добавляем в хвост дека.
Далее сравниваем первый и последний символ дека.
*/

//ЗАДАЧА 4 
/*
Описать структуру данных List.
Продемонстрировать работу с этой структурой:
ввод, вывод,
добавление элемента и удаление,
сортировка.
*/

//ЗАДАЧА 5 
/*
Описать структуру данных Set.
Продемонстрировать работу с этой структурой:
ввод, вывод,
добавление элемента и удаление.
*/

//ЗАДАЧА 6 
/*
Описать структуру данных map.
Продемонстрировать работу с этой структурой:
ввод, вывод,
добавление элемента и удаление.
*/

// ЗАДАЧА 7 
/*
Составить таблицу сравнения по времени выполнения операций
для дека, стека, очереди, списка, множества, массива из n элементов.
Список операций:
добавление в начало
добавление в конец
добавление в середину
удаление из начала
удаление с конца
удаление из середины
значение элемента из начала
значение элемента с конца
значение элемента из середины
*/
	system("pause");
	return 0;
}